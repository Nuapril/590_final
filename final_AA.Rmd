---
title: "Data Analysis"
author: "April Armes"
date: "May 5, 2017"
output: github_document
---

# Introduction
Gene transcripts based on normalized relative quanities (nrq) are often difficult to calculate. Here, I present script written that calculates nrq based on efficiency (E) and cycle threshold (Ct) values generated by quantitaive-Polymerase Chain Reaction. Note that this script is only useful for relative quantification of gene expression. It requires several dataframes in which there are three technical replicates for your control, experimental, 3 reference genes, and at least one gene of interest (GOI). 

Here, I am measuring the expression of igiD as my GOI. Comparing this value in four experimental mutants to the wildtype (WT) control. Each mutant GOI as well as 3 reference genes (alaS, map, rpoC) will be compared to that of WT. The E and Ct values generated by qPCR for each of these genes will be used to calculate nqr. Nqr is then used to determine the upregulation or down regulation of a gene. 




```{r}
### Libraries needed for this script
library(dplyr)
library(ggplot2)
```

# The Data
For the purpose of this script and data analysis, each qPCR run is set up in a .csv file. This file contains the control mutant (Y4I), one experimental mutant, replicate number, the gene measured (alaS, map, rpoC, igiD), their E and Ct values. 


## Part I
### Comparing Y4I and pgaR
  *The data frame should be set up with columns labeled "sample", "gene", "replicate", "E", and "Ct"
  *Generate data frame with the above specified columns. Can be entered at .csv
```{r}
test3 <- read.csv("../590_final/test3.csv")

##this code reads a .csv file from a relative pathway into an object called test3. Passing commands through objects saves them to the global enviroment which allows viewing at any time
```

  *Calculate the geometric mean of "E", the geometric standard deviation of "E", the average cycle threshold ("Ct"), and the standard deviation of the average "Ct" of each gene in each sample
  *This is where your replicates come in. In order to calculate these values you must have more than 1 value to input
 
  
```{r}
## In order to calculate geometric mean and geometric standard deviation, I had to write a couple functions
## geo_mean and geo_sd functions

#this function calculates the geometric mean of a vector
geo_mean <- function(x) {  
  #need to put if statements into function
  geomean <- exp(sum(log(x[x > 0]), na.rm = TRUE) / length(x))
  return(geomean)
}

#this function calculates the geometric stadard deviation of a vector
geo_sd <- function(x) {
  #need to put if statements into function
  geosd <- exp(sd(log(1+x)-1))-1
  return(geosd)
}
```

  *Create a data frame that contains the above calculations
```{r}
data1 <- test3 %>% 
  group_by(gene, sample) %>% #this data set is grouped by gene and sample in order to calculate geo_mean, geo_sd, average "Ct", and standard deviation of "Ct" by each gene in each sample
  summarise(geo.mean = geo_mean(E), 
            geo.sd = geo_sd(E),
            Mean.Ct = mean(ct), 
            SD.Ct = sd(ct)
  )
## test3 is piped into this grouping which is then passed through summarise, creating a new dataframe with new columns
## new columns (left side of equation) = geo.mean, geo.sd, Mean.Ct, and SD.Ct
## functions/calculations are on the right side of the equation. 
# must have exisiting columns in dataframe from which to calculate new values (ie "E", "ct"). 

print(data1) #prints table to console so that you can make sure everything is working
```

 * Calculate the difference in Mean.Ct between samples 
   *Because this task reduces the number of rows in the dataframe, we must print a new table

```{r}
data2 <- 
  ungroup(data1) %>% # we want to ungroup our df to go back to the original (no longer grouping by both gene and sample)
  group_by(gene) %>% # then we want to regroup by gene
  summarise(d.Ct = Mean.Ct[sample == "Y4I"] - Mean.Ct[sample == "pgaR"]) #this will create a new table with the desired values
print(data2)


## this half step is necessary to join the exisiting df (data1 and data2) to perform the next set of calculations 
data2.5 <- data1 %>% 
  filter(sample == "Y4I") %>% #here we take data1 and filter out everything expect for values for our control sample ("Y4I")
  left_join(data2, by = "gene") %>% #then we join this df to data2 and organize by the column gene, this works because there are the same number of values for each column
  mutate(rq = geo.mean[sample == "Y4I"]^d.Ct[sample == "Y4I"], #next we add two new columns using the mutate function that calculate relative quantification (rq) based on Ct values
         rq.sd = rq*sqrt((d.Ct*geo.sd/geo.mean)^2 + (log(geo.mean)*SD.Ct)^2)# and the sd of rq
  )
print(data2.5)
```


  *Generate a table with the Normalization factor(nf), sd of nf, Normalized Relative Quantity (nrq), and sd of nrq
    *This must be generated in a new table because only one value for each column will be generated
```{r}
data3 <- 
  ungroup(data2.5) %>% #it is neccessary to ungroup this df 
  summarise(nf = ((rq[gene == "alaS"]*rq[gene == "map"]*rq[gene == "rpoC"])^(1/3)),
            nf.sd = nf*sqrt((rq.sd[gene == "rpoC"]/(3*rq[gene == "rpoC"]))^2 + 
                              ((rq.sd[gene == "map"])/(3*rq[gene == "map"]))^2 + 
                              ((rq.sd[gene == "alaS"])/(3*rq[gene == "alaS"]))^2),
            nrq = rq[gene == "igiD"]/nf,
            nrq.sd = nrq*sqrt((nf.sd/nf)^2 + (rq.sd[gene == "igiD"]/rq[gene == "igiD"])^2)
  )
##the summarise function creates a new table and creates four new columns of one value each
print(data3)
```

Because this is only one comparison between GOI in experimental sample and GOI in control, we must run several more df 
This is where writing functions/package would be useful.

### Part II

# Comparing Y4I and phaR

This uses the same script as above

```{r}

test4 <- read.csv("../590_final/test4.csv")

data4 <- test4 %>% 
  group_by(gene, sample) %>% 
  summarise(geo.mean = geo_mean(E), 
            geo.sd = geo_sd(E),
            Mean.Ct = mean(ct), 
            SD.Ct = sd(ct)
  )

print(data4) 


data5 <- 
  ungroup(data4) %>% 
  group_by(gene) %>% 
  summarise(d.Ct = Mean.Ct[sample == "Y4I"] - Mean.Ct[sample == "phaR"]) 
print(data2)

 
data5.5 <- data4 %>% 
  filter(sample == "Y4I") %>% 
  left_join(data5, by = "gene") %>% 
  mutate(rq = geo.mean[sample == "Y4I"]^d.Ct[sample == "Y4I"], 
         rq.sd = rq*sqrt((d.Ct*geo.sd/geo.mean)^2 + (log(geo.mean)*SD.Ct)^2)
  )
print(data5.5)


data6<- 
  ungroup(data5.5) %>%  
  summarise(nf = ((rq[gene == "alaS"]*rq[gene == "map"]*rq[gene == "rpoC"])^(1/3)),
            nf.sd = nf*sqrt((rq.sd[gene == "rpoC"]/(3*rq[gene == "rpoC"]))^2 + 
                              ((rq.sd[gene == "map"])/(3*rq[gene == "map"]))^2 + 
                              ((rq.sd[gene == "alaS"])/(3*rq[gene == "alaS"]))^2),
            nrq = rq[gene == "igiD"]/nf,
            nrq.sd = nrq*sqrt((nf.sd/nf)^2 + (rq.sd[gene == "igiD"]/rq[gene == "igiD"])^2)
  )

print(data6)
```

## Part III
## Comparing Y4I and phaI

This uses the same script as above

```{r}

test5 <- read.csv("../590_final/test5.csv")
print(test5)

data7 <- test5 %>% 
  group_by(gene, sample) %>% 
  summarise(geo.mean = geo_mean(E), 
            geo.sd = geo_sd(E),
            Mean.Ct = mean(ct), 
            SD.Ct = sd(ct)
  )

print(data7) 


data8 <- 
  ungroup(data7) %>% 
  group_by(gene) %>% 
  summarise(d.Ct = Mean.Ct[sample == "Y4I"] - Mean.Ct[sample == "phaI"]) 
print(data8)


data8.5 <- data7 %>% 
  filter(sample == "Y4I") %>% 
  left_join(data8, by = "gene") %>% 
  mutate(rq = geo.mean[sample == "Y4I"]^d.Ct[sample == "Y4I"], 
         rq.sd = rq*sqrt((d.Ct*geo.sd/geo.mean)^2 + (log(geo.mean)*SD.Ct)^2)
  )
print(data8.5)


data9 <- 
  ungroup(data8.5) %>%  
  summarise(nf = ((rq[gene == "alaS"]*rq[gene == "map"]*rq[gene == "rpoC"])^(1/3)),
            nf.sd = nf*sqrt((rq.sd[gene == "rpoC"]/(3*rq[gene == "rpoC"]))^2 + 
                              ((rq.sd[gene == "map"])/(3*rq[gene == "map"]))^2 + 
                              ((rq.sd[gene == "alaS"])/(3*rq[gene == "alaS"]))^2),
            nrq = rq[gene == "igiD"]/nf,
            nrq.sd = nrq*sqrt((nf.sd/nf)^2 + (rq.sd[gene == "igiD"]/rq[gene == "igiD"])^2)
  )

print(data9)
```

## Part IV
### Comparing Y4I and igiD

This uses the same script as above

```{r}

test6 <- read.csv("../590_final/test6.csv")
print(test6)

data10 <- test6 %>% 
  group_by(gene, sample) %>% 
  summarise(geo.mean = geo_mean(E), 
            geo.sd = geo_sd(E),
            Mean.Ct = mean(ct), 
            SD.Ct = sd(ct)
  )

print(data10) 


data11 <- 
  ungroup(data10) %>% 
  group_by(gene) %>% 
  summarise(d.Ct = Mean.Ct[sample == "Y4I"] - Mean.Ct[sample == "igiD"]) 
print(data11)


data11.5 <- data10 %>% 
  filter(sample == "Y4I") %>% 
  left_join(data11, by = "gene") %>% 
  mutate(rq = geo.mean[sample == "Y4I"]^d.Ct[sample == "Y4I"], 
         rq.sd = rq*sqrt((d.Ct*geo.sd/geo.mean)^2 + (log(geo.mean)*SD.Ct)^2)
  )
print(data11.5)


data12<- 
  ungroup(data11.5) %>%  
  summarise(nf = ((rq[gene == "alaS"]*rq[gene == "map"]*rq[gene == "rpoC"])^(1/3)),
            nf.sd = nf*sqrt((rq.sd[gene == "rpoC"]/(3*rq[gene == "rpoC"]))^2 + 
                              ((rq.sd[gene == "map"])/(3*rq[gene == "map"]))^2 + 
                              ((rq.sd[gene == "alaS"])/(3*rq[gene == "alaS"]))^2),
            nrq = rq[gene == "igiD"]/nf,
            nrq.sd = nrq*sqrt((nf.sd/nf)^2 + (rq.sd[gene == "igiD"]/rq[gene == "igiD"])^2)
  )

print(data12)
```
# Data Analysis
This script uses the normalized relative quantities generated through the calculations above to determine gene expression of the GOI. As the expression is normalized to reference genes, which are assumed to be constant, anything below 1 is down regulated and anything above 1 is upregulated.  

### Getting the relevant data
  * Combine nrq from all data sets into one table by sample name
  * Create a new dataframe with all samples ( pgaR, phaR, phaI, igiD) and the nrq for each sample
  
```{r}

#This creates a list with the sample names
sample.names <- c("pgaR", "phaR", "phaI", "igiD") 
y4i.values <- c(0, 0, 1, 0)

#This coerces the list into a data frame
df.sample <- as.data.frame(sample.names, row.names = NULL) 
print(df.sample)
#y4i.df <-as.data.frame(y4i.values, row.names = NULL)
#print(y4i.df)

#This creates a data frame from the last data set from each sample comparison by binding rows
#Then it adds the previous data frame containing sample names
#and selects the relevant columns
df <- data3 %>%
  bind_rows(data6, data9, data12) %>%
  bind_cols(df.sample) %>%
  select(nrq, nrq.sd, sample.names)

print(df)

```


### Plotting the data

```{r}
p1 <- p<-ggplot(data = df, aes (x = sample.names, y = nrq))+ geom_bar(stat="identity", position = "dodge")+ geom_errorbar(aes(ymax = nrq + nrq.sd, ymin = nrq - nrq.sd), width = 0.45)  #bar plot with error bars using data summary with sample averages and standard devations. 


# add chart title, rename x and y labels
p2 <- p1 + ggtitle("igiD Expression") + theme(plot.title = element_text(hjust = 0.5)) + ylab("Normalized Relative Transcripts") + xlab("Mutant")


#add asteriks over significantly different expression
label.phaI <-data.frame (sample.names = c( "phaI"), nrq = c(0.01))
label.phaR <- data.frame (sample.names = c( "phaR"), nrq = c(0.01))
p3 <-p2 + geom_text(data = label.phaI, label = "***")
p4 <- p3 + geom_text(data = label.phaR, label = "***")
plot(p4)
```

As shown from igiD Expression plot, the expression of igiD is downregulated in all mutants when compared to wildtype. 